"""
VWAP Mean Reversion Trading System - IBKR API Implementation

This system:
1. Monitors price action during 3-4 PM hour
2. Detects absorption patterns at 15:59
3. Calculates daily VWAP target
4. Places after-hours trades with 2:1 RR
5. Manages positions automatically until 8 PM

Recommended symbols: SPY, BAC, XLB, VTI, XLP
"""

import asyncio
from datetime import datetime, time, timedelta
from typing import Dict, List, Optional
import pandas as pd
import numpy as np
from ib_async import IB, Stock, MarketOrder, LimitOrder, Order, util
import logging
from dataclasses import dataclass
from enum import Enum

# ============================================================================
# CONFIGURATION
# ============================================================================

class Config:
    """Trading system configuration"""
    
    # Connection
    IBKR_HOST = '127.0.0.1'
    IBKR_PORT = 7497  # 7497 for TWS paper, 7496 for TWS live, 4002 for Gateway
    CLIENT_ID = 1
    
    # Symbols to trade (ranked by performance)
    SYMBOLS = ['SPY', 'BAC', 'XLB', 'VTI', 'XLP']
    
    # Risk management
    RISK_PER_TRADE = 1000  # Risk $1000 per trade
    MAX_POSITIONS = 5  # Maximum concurrent positions
    MAX_DAILY_LOSS = 3000  # Stop trading if down $3000 in a day
    
    # Strategy parameters
    ABSORPTION_MOVE_THRESHOLD = 0.30  # Hour must move >$0.30
    ABSORPTION_IMPACT_RATIO = 0.20    # Last candle impact <20% of hour move
    RISK_REWARD_RATIO = 2.0           # 2:1 RR
    
    # Timing
    MARKET_OPEN = time(9, 30)
    POSITION_CHECK_START = time(15, 0)   # Start monitoring at 3 PM
    SIGNAL_CHECK_TIME = time(15, 59)     # Check for signals at 3:59 PM
    ENTRY_TIME = time(16, 0)             # Enter trades at 4:00 PM
    EXIT_DEADLINE = time(20, 0)          # Exit all positions by 8 PM
    
    # Logging
    LOG_LEVEL = logging.INFO
    LOG_FILE = 'vwap_trading.log'


class TradeDirection(Enum):
    """Trade direction enum"""
    LONG = "LONG"
    SHORT = "SHORT"


@dataclass
class AbsorptionSignal:
    """Data class for absorption signal"""
    symbol: str
    timestamp: datetime
    hour_open: float
    hour_close: float
    hour_move: float
    candle_move: float
    impact_ratio: float
    vwap_target: float
    direction: TradeDirection
    entry_price: float
    stop_loss: float
    take_profit: float
    shares: int
    is_valid: bool = True


@dataclass
class Position:
    """Active position tracking"""
    symbol: str
    direction: TradeDirection
    entry_price: float
    shares: int
    stop_loss: float
    take_profit: float
    entry_time: datetime
    order_id: Optional[int] = None
    

# ============================================================================
# LOGGING SETUP
# ============================================================================

def setup_logging():
    """Configure logging"""
    logging.basicConfig(
        level=Config.LOG_LEVEL,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(Config.LOG_FILE),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger(__name__)

logger = setup_logging()


# ============================================================================
# VWAP CALCULATOR
# ============================================================================

class VWAPCalculator:
    """Calculate intraday VWAP"""
    
    def __init__(self):
        self.bars: Dict[str, pd.DataFrame] = {}
    
    def add_bar(self, symbol: str, bar):
        """Add a new bar to the calculation"""
        if symbol not in self.bars:
            self.bars[symbol] = pd.DataFrame()
        
        new_row = {
            'timestamp': pd.to_datetime(bar.date),
            'open': bar.open,
            'high': bar.high,
            'low': bar.low,
            'close': bar.close,
            'volume': bar.volume
        }
        
        self.bars[symbol] = pd.concat([
            self.bars[symbol], 
            pd.DataFrame([new_row])
        ], ignore_index=True)
    
    def calculate_vwap(self, symbol: str, up_to_time: time = time(15, 59)) -> Optional[float]:
        """
        Calculate VWAP up to specified time
        
        Args:
            symbol: Stock symbol
            up_to_time: Calculate VWAP up to this time (default 3:59 PM)
            
        Returns:
            VWAP value or None if insufficient data
        """
        if symbol not in self.bars or self.bars[symbol].empty:
            logger.warning(f"No bar data for {symbol}")
            return None
        
        df = self.bars[symbol].copy()
        df['time'] = df['timestamp'].dt.time
        
        # Filter to market hours up to specified time
        mask = (df['time'] >= Config.MARKET_OPEN) & (df['time'] <= up_to_time)
        df_filtered = df[mask].copy()
        
        if df_filtered.empty or df_filtered['volume'].sum() == 0:
            logger.warning(f"Insufficient volume data for {symbol}")
            return None
        
        # Calculate VWAP: sum(price * volume) / sum(volume)
        typical_price = (df_filtered['high'] + df_filtered['low'] + df_filtered['close']) / 3
        vwap = (typical_price * df_filtered['volume']).sum() / df_filtered['volume'].sum()
        
        logger.info(f"{symbol} VWAP at {up_to_time}: ${vwap:.2f}")
        return vwap
    
    def get_hour_data(self, symbol: str, hour: int = 15) -> Optional[Dict]:
        """
        Get first and last bar of specified hour
        
        Args:
            symbol: Stock symbol
            hour: Hour to analyze (default 15 for 3 PM hour)
            
        Returns:
            Dict with hour_open and hour_close prices
        """
        if symbol not in self.bars or self.bars[symbol].empty:
            return None
        
        df = self.bars[symbol].copy()
        df['hour'] = df['timestamp'].dt.hour
        
        hour_bars = df[df['hour'] == hour]
        if hour_bars.empty:
            return None
        
        return {
            'hour_open': hour_bars.iloc[0]['open'],
            'hour_close': hour_bars.iloc[-1]['close']
        }
    
    def reset_daily(self):
        """Reset VWAP calculation for new day"""
        self.bars = {}
        logger.info("VWAP calculator reset for new trading day")


# ============================================================================
# ABSORPTION DETECTOR
# ============================================================================

class AbsorptionDetector:
    """Detect absorption patterns at 3:59 PM"""
    
    def __init__(self, vwap_calc: VWAPCalculator):
        self.vwap_calc = vwap_calc
    
    def detect_signal(self, symbol: str, current_bar) -> Optional[AbsorptionSignal]:
        """
        Detect absorption signal at 3:59 PM
        
        Args:
            symbol: Stock symbol
            current_bar: Current 1-minute bar at 3:59
            
        Returns:
            AbsorptionSignal if valid, else None
        """
        # Get hour data (3 PM - 3:59 PM)
        hour_data = self.vwap_calc.get_hour_data(symbol, hour=15)
        if not hour_data:
            logger.warning(f"{symbol}: No hour data available")
            return None
        
        # Calculate VWAP target
        vwap = self.vwap_calc.calculate_vwap(symbol)
        if not vwap:
            logger.warning(f"{symbol}: Could not calculate VWAP")
            return None
        
        # Calculate absorption metrics
        hour_open = hour_data['hour_open']
        hour_close = current_bar.close
        hour_move = hour_close - hour_open
        
        candle_open = current_bar.open
        candle_close = current_bar.close
        candle_move = abs(candle_close - candle_open)
        
        impact_ratio = candle_move / (abs(hour_move) + 1e-6)
        
        # Check absorption criteria
        is_absorption = (
            abs(hour_move) > Config.ABSORPTION_MOVE_THRESHOLD and
            impact_ratio < Config.ABSORPTION_IMPACT_RATIO
        )
        
        if not is_absorption:
            logger.debug(
                f"{symbol}: No absorption - "
                f"hour_move=${hour_move:.2f}, impact_ratio={impact_ratio:.2%}"
            )
            return None
        
        # Determine trade direction (mean reversion to VWAP)
        if candle_close < vwap:
            direction = TradeDirection.LONG
        else:
            direction = TradeDirection.SHORT
        
        # Calculate entry, stop, and target
        entry_price = candle_close
        distance_to_target = vwap - entry_price
        
        if direction == TradeDirection.LONG:
            take_profit = vwap
            stop_loss = entry_price - (distance_to_target / Config.RISK_REWARD_RATIO)
        else:  # SHORT
            take_profit = vwap
            stop_loss = entry_price + (abs(distance_to_target) / Config.RISK_REWARD_RATIO)
        
        # Calculate position size
        stop_distance = abs(entry_price - stop_loss)
        if stop_distance < 0.01:  # Minimum stop distance
            logger.warning(f"{symbol}: Stop distance too small: ${stop_distance:.2f}")
            return None
        
        shares = int(Config.RISK_PER_TRADE / stop_distance)
        
        signal = AbsorptionSignal(
            symbol=symbol,
            timestamp=datetime.now(),
            hour_open=hour_open,
            hour_close=hour_close,
            hour_move=hour_move,
            candle_move=candle_move,
            impact_ratio=impact_ratio,
            vwap_target=vwap,
            direction=direction,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            shares=shares,
            is_valid=True
        )
        
        logger.info(
            f"üéØ ABSORPTION DETECTED: {symbol}\n"
            f"  Direction: {direction.value}\n"
            f"  Hour Move: ${hour_move:.2f}\n"
            f"  Impact Ratio: {impact_ratio:.2%}\n"
            f"  Entry: ${entry_price:.2f}\n"
            f"  Target (VWAP): ${take_profit:.2f}\n"
            f"  Stop: ${stop_loss:.2f}\n"
            f"  Shares: {shares}\n"
            f"  Risk: ${shares * stop_distance:.2f}"
        )
        
        return signal


# ============================================================================
# IBKR TRADING CLIENT
# ============================================================================

class IBKRTradingClient:
    """Interactive Brokers trading client"""
    
    def __init__(self):
        self.ib = IB()
        self.connected = False
        self.positions: Dict[str, Position] = {}
        self.daily_pnl = 0.0
        self.vwap_calc = VWAPCalculator()
        self.detector = AbsorptionDetector(self.vwap_calc)
        self.pending_signals: List[AbsorptionSignal] = []
        
    async def connect(self):
        """Connect to IBKR"""
        try:
            await self.ib.connectAsync(
                Config.IBKR_HOST,
                Config.IBKR_PORT,
                clientId=Config.CLIENT_ID
            )
            self.connected = True
            logger.info(f"‚úÖ Connected to IBKR at {Config.IBKR_HOST}:{Config.IBKR_PORT}")
            
            # Subscribe to account updates
            self.ib.accountSummaryEvent += self.on_account_update
            
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to IBKR: {e}")
            raise
    
    async def disconnect(self):
        """Disconnect from IBKR"""
        if self.connected:
            self.ib.disconnect()
            self.connected = False
            logger.info("Disconnected from IBKR")
    
    def on_account_update(self, values):
        """Handle account updates"""
        for v in values:
            if v.tag == 'DailyPnL':
                self.daily_pnl = float(v.value)
                logger.debug(f"Daily P&L: ${self.daily_pnl:.2f}")
    
    async def get_contract(self, symbol: str) -> Stock:
        """Get qualified contract for symbol"""
        contract = Stock(symbol, 'SMART', 'USD')
        await self.ib.qualifyContractsAsync(contract)
        return contract
    
    async def get_current_price(self, symbol: str) -> Optional[float]:
        """Get current market price"""
        contract = await self.get_contract(symbol)
        ticker = self.ib.reqMktData(contract, '', False, False)
        await asyncio.sleep(1)  # Wait for data
        
        # Use mid-point of bid-ask or last price
        if ticker.bid and ticker.ask:
            price = (ticker.bid + ticker.ask) / 2
        elif ticker.last:
            price = ticker.last
        else:
            logger.warning(f"{symbol}: No price data available")
            return None
        
        self.ib.cancelMktData(contract)
        return price
    
    async def stream_bars(self, symbol: str):
        """Stream 1-minute bars for a symbol"""
        contract = await self.get_contract(symbol)
        
        # Request real-time bars (5-second bars)
        bars = self.ib.reqRealTimeBars(
            contract, 
            5,  # 5-second bars
            'TRADES', 
            False
        )
        
        bars.updateEvent += lambda bars, hasNewBar: self.on_bar_update(symbol, bars)
        logger.info(f"üìä Started streaming bars for {symbol}")
    
    def on_bar_update(self, symbol: str, bars):
        """Handle new bar updates"""
        if bars:
            latest_bar = bars[-1]
            self.vwap_calc.add_bar(symbol, latest_bar)
            
            # Check for signals at 3:59 PM
            current_time = datetime.now().time()
            if current_time.hour == 15 and current_time.minute == 59:
                signal = self.detector.detect_signal(symbol, latest_bar)
                if signal:
                    self.pending_signals.append(signal)
    
    async def place_order(self, signal: AbsorptionSignal) -> Optional[int]:
        """
        Place market order based on signal
        
        Args:
            signal: AbsorptionSignal to trade
            
        Returns:
            Order ID if successful, None otherwise
        """
        # Check risk limits
        if len(self.positions) >= Config.MAX_POSITIONS:
            logger.warning(f"Max positions ({Config.MAX_POSITIONS}) reached, skipping {signal.symbol}")
            return None
        
        if self.daily_pnl < -Config.MAX_DAILY_LOSS:
            logger.warning(f"Daily loss limit reached (${self.daily_pnl:.2f}), skipping trades")
            return None
        
        try:
            contract = await self.get_contract(signal.symbol)
            
            # Create market order
            action = 'BUY' if signal.direction == TradeDirection.LONG else 'SELL'
            order = MarketOrder(action, signal.shares)
            
            # Place order
            trade = self.ib.placeOrder(contract, order)
            await asyncio.sleep(1)  # Wait for fill
            
            logger.info(
                f"üì§ ORDER PLACED: {action} {signal.shares} {signal.symbol} @ Market\n"
                f"  Target: ${signal.take_profit:.2f}\n"
                f"  Stop: ${signal.stop_loss:.2f}"
            )
            
            # Track position
            position = Position(
                symbol=signal.symbol,
                direction=signal.direction,
                entry_price=signal.entry_price,
                shares=signal.shares,
                stop_loss=signal.stop_loss,
                take_profit=signal.take_profit,
                entry_time=datetime.now(),
                order_id=trade.order.orderId
            )
            self.positions[signal.symbol] = position
            
            # Place bracket orders (stop and target)
            await self.place_bracket_orders(position)
            
            return trade.order.orderId
            
        except Exception as e:
            logger.error(f"‚ùå Failed to place order for {signal.symbol}: {e}")
            return None
    
    async def place_bracket_orders(self, position: Position):
        """Place stop loss and take profit orders"""
        try:
            contract = await self.get_contract(position.symbol)
            
            # Determine action for exit (opposite of entry)
            exit_action = 'SELL' if position.direction == TradeDirection.LONG else 'BUY'
            
            # Stop loss order
            stop_order = Order()
            stop_order.action = exit_action
            stop_order.totalQuantity = position.shares
            stop_order.orderType = 'STP'
            stop_order.auxPrice = position.stop_loss
            stop_order.tif = 'GTC'  # Good till cancelled
            
            # Take profit order
            profit_order = Order()
            profit_order.action = exit_action
            profit_order.totalQuantity = position.shares
            profit_order.orderType = 'LMT'
            profit_order.lmtPrice = position.take_profit
            profit_order.tif = 'GTC'
            
            # Place orders
            self.ib.placeOrder(contract, stop_order)
            self.ib.placeOrder(contract, profit_order)
            
            logger.info(
                f"üõ°Ô∏è BRACKET ORDERS PLACED: {position.symbol}\n"
                f"  Stop @ ${position.stop_loss:.2f}\n"
                f"  Target @ ${position.take_profit:.2f}"
            )
            
        except Exception as e:
            logger.error(f"‚ùå Failed to place bracket orders for {position.symbol}: {e}")
    
    async def check_positions(self):
        """Monitor and manage active positions"""
        for symbol in list(self.positions.keys()):
            position = self.positions[symbol]
            
            # Get current price
            current_price = await self.get_current_price(symbol)
            if not current_price:
                continue
            
            # Check if target hit
            if position.direction == TradeDirection.LONG:
                if current_price >= position.take_profit:
                    logger.info(f"‚úÖ TARGET HIT: {symbol} @ ${current_price:.2f}")
                    await self.close_position(symbol)
                elif current_price <= position.stop_loss:
                    logger.info(f"üõë STOP HIT: {symbol} @ ${current_price:.2f}")
                    await self.close_position(symbol)
            else:  # SHORT
                if current_price <= position.take_profit:
                    logger.info(f"‚úÖ TARGET HIT: {symbol} @ ${current_price:.2f}")
                    await self.close_position(symbol)
                elif current_price >= position.stop_loss:
                    logger.info(f"üõë STOP HIT: {symbol} @ ${current_price:.2f}")
                    await self.close_position(symbol)
    
    async def close_position(self, symbol: str):
        """Close a position"""
        if symbol not in self.positions:
            return
        
        position = self.positions[symbol]
        
        try:
            contract = await self.get_contract(symbol)
            
            # Close position with market order
            action = 'SELL' if position.direction == TradeDirection.LONG else 'BUY'
            order = MarketOrder(action, position.shares)
            
            trade = self.ib.placeOrder(contract, order)
            await asyncio.sleep(1)
            
            # Calculate P&L
            current_price = await self.get_current_price(symbol)
            if current_price:
                if position.direction == TradeDirection.LONG:
                    pnl = (current_price - position.entry_price) * position.shares
                else:
                    pnl = (position.entry_price - current_price) * position.shares
                
                logger.info(
                    f"üí∞ POSITION CLOSED: {symbol}\n"
                    f"  Entry: ${position.entry_price:.2f}\n"
                    f"  Exit: ${current_price:.2f}\n"
                    f"  P&L: ${pnl:.2f}"
                )
            
            # Remove from active positions
            del self.positions[symbol]
            
        except Exception as e:
            logger.error(f"‚ùå Failed to close position {symbol}: {e}")
    
    async def close_all_positions(self):
        """Close all open positions (used at end of day)"""
        logger.info("üî¥ Closing all positions at end of trading window")
        symbols = list(self.positions.keys())
        for symbol in symbols:
            await self.close_position(symbol)
    
    async def run_trading_day(self):
        """Main trading loop for a day"""
        logger.info("="*80)
        logger.info("üöÄ VWAP MEAN REVERSION TRADING SYSTEM STARTED")
        logger.info("="*80)
        
        # Reset for new day
        self.vwap_calc.reset_daily()
        self.pending_signals = []
        
        # Start streaming bars for all symbols
        for symbol in Config.SYMBOLS:
            await self.stream_bars(symbol)
        
        # Main loop
        while True:
            current_time = datetime.now().time()
            
            # Execute pending signals at 4:00 PM
            if current_time.hour == 16 and current_time.minute == 0 and self.pending_signals:
                logger.info(f"‚è∞ 4:00 PM - Executing {len(self.pending_signals)} signals")
                for signal in self.pending_signals:
                    await self.place_order(signal)
                self.pending_signals = []
            
            # Monitor positions every minute
            if current_time >= Config.ENTRY_TIME:
                await self.check_positions()
            
            # Close all positions at 8 PM
            if current_time >= Config.EXIT_DEADLINE:
                await self.close_all_positions()
                logger.info("üõë Trading day complete")
                break
            
            # Sleep before next check
            await asyncio.sleep(30)  # Check every 30 seconds


# ============================================================================
# MAIN EXECUTION
# ============================================================================

async def main():
    """Main entry point"""
    client = IBKRTradingClient()
    
    try:
        # Connect to IBKR
        await client.connect()
        
        # Run trading day
        await client.run_trading_day()
        
    except KeyboardInterrupt:
        logger.info("‚ö†Ô∏è Interrupted by user")
    except Exception as e:
        logger.error(f"‚ùå Fatal error: {e}", exc_info=True)
    finally:
        # Clean up
        await client.close_all_positions()
        await client.disconnect()
        logger.info("üëã System shutdown complete")


if __name__ == "__main__":
    # Run the async main function
    asyncio.run(main())
